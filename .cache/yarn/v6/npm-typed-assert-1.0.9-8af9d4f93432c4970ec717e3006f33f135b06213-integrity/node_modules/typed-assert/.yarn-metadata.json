{
  "manifest": {
    "name": "typed-assert",
    "version": "1.0.9",
    "description": "typesafe assertion library for TypeScript 3.7+",
    "main": "build/index.js",
    "scripts": {
      "test:src": "jest src/**/*.test.ts",
      "test:build": "jest build/**/*.test.js",
      "clean:doc": "rm -rf doc && rm -rf API.md",
      "build:doc": "npm run clean:doc && typedoc && sed s/README.md/API.md/ doc/README.md > API.md && rm -rf doc",
      "clean:ts": "rm -rf build",
      "build:ts": "npm run clean:ts && tsc -p .",
      "build": "npm run build:doc && npm run build:ts"
    },
    "repository": {
      "type": "git",
      "url": "git+https://github.com/elierotenberg/typed-assert.git"
    },
    "keywords": [
      "assert",
      "typescript"
    ],
    "author": {
      "name": "Elie Rotenberg",
      "email": "elie@rotenberg.io"
    },
    "license": "MIT",
    "bugs": {
      "url": "https://github.com/elierotenberg/typed-assert/issues"
    },
    "homepage": "https://github.com/elierotenberg/typed-assert#readme",
    "devDependencies": {
      "@types/jest": "^27.4.0",
      "@types/node": "^17.0.18",
      "@typescript-eslint/eslint-plugin": "^5.12.0",
      "@typescript-eslint/parser": "^5.12.0",
      "eslint": "^8.9.0",
      "eslint-config-prettier": "^8.3.0",
      "eslint-plugin-import": "^2.25.4",
      "eslint-plugin-prettier": "^4.0.0",
      "jest": "^27.5.1",
      "prettier": "^2.5.1",
      "ts-jest": "^27.1.3",
      "typedoc": "^0.22.11",
      "typedoc-plugin-markdown": "^3.11.14",
      "typescript": "^4.5.5"
    },
    "_registry": "npm",
    "_loc": "/home/runner/website-breaker2/.cache/yarn/v6/npm-typed-assert-1.0.9-8af9d4f93432c4970ec717e3006f33f135b06213-integrity/node_modules/typed-assert/package.json",
    "readmeFilename": "README.md",
    "readme": "# `typed-assert`\n\n`typed-assert` is a typesafe assertion library implementing the [TS 3.7 Assertion Functions](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions) API, without external dependencies.\n\nSee the [documentation](API.md).\n\n### Consider using [`zod`](https://github.com/colinhacks/zod)\n\nWhile this library does a fine job for most simple use cases, please consider using [`zod`](https://github.com/colinhacks/zod) if you need more complex assertions.\n\n### Install\n\n```npm install typed-assert```\n\nor\n\n```yarn add typed-assert```\n\n### Why is it useful?\n\n`typed-assert` promotes using `unknown` instead of `any` for \"untrusted\" values, e.g. user input, while still benefiting from incremental typing.\n\nFor example, `JSON.stringify` returns `any`, which is not typesafe. With `typed-assert`, we can instead treat the result as `unknown` and gradually check the contents at runtime and still get correct type inference:\n\n```ts\nimport * as t from \"typed-assert\";\n\nconst parseConfigFile = (file: string): { readonly a: string, readonly b: number } => {\n  const contents = JSON.parse(fs.readFileSync(file, { encoding: 'utf8'})) as unknown;\n  // contents is \"unknown\" instead of any, because we don't trust the input yet\n  t.isRecord(contents);\n  // contents is \"Record<string, unknown>\"\n  t.isString(contents.a);\n  // contents.a is \"string\"\n  t.isNumber(contents.b):\n  // contents.b is \"number\";\n  return {\n    a: contents.a,\n    b: contents.b,\n  }; // correctly typed\n}\n```\n\n### How is it different from chai, jest.expect, etc?\n\n`typed-assert` is both a compile-time and runtime assert library. It leverages the `assertion function` feature of TypeScript to help the typechecker narrow the inferred types. In many cases, this significantly reduces the need to use `any`, and promotes using `unknown` instead.\n\nFor example:\n\n```ts\nconst u: unknown = {\n  a: \"value\",\n  b: 12,\n};\n\nchai.assert.typeOf(u, \"object\");\n// u is still \"unknown\"\nchai.assert.isNotNull(u);\n// u is still \"unknown\"\nchai.assert.typeof(u.a, \"string\");\n// TS Error (ts2571): u is \"unknown\"\n\nimport * as t from \"typed-assert\";\n\nt.isRecord(u);\n// u is Record<string, unknown>\nt.isString(u.a);\n// u.a is string\nt.isNumber(u.b);\n// u.b is number\n\nconst v: { a: string; b: number } = u;\n// no need to us `as ...`\n```\n\n### Usage\n\n`typed-assert` comes with a set of common assertions, as well as assertion combinators and utilities.\n\nSee [the documentation](./API.md) for a full reference.\n\n```ts\nimport * as t from \"typed-assert\";\n\n// Base asserts\nt.isExactly(\"a\", \"a\");\nt.isNotUndefined(null);\nt.isNotNull(undefined);\n\n// Asserts combinators\nt.isOneOf(\"b\", [\"a\", \"b\", \"c\"]);\nt.isArrayOf([2, 3, 4], t.isNumber);\n\n// Custom composite checks\ninterface ICustomType {\n  readonly a: {\n    readonly b: \"c\";\n    readonly d: string;\n  };\n  readonly f?: number;\n}\n\nfunction assertCustomType(input: unknown): asserts input is ICustomType {\n  t.isRecordWithKeys(input, [\"a\", \"f\"]);\n  t.isRecordWithKeys(input.a, [\"b\", \"d\"]);\n  t.isExactly(input.a.b, \"c\");\n  t.isString(input.a.d);\n  t.isOption(input.f, t.isNumber);\n}\n\nconst v = {\n  a: {\n    b: \"c\",\n    d: \"\",\n  },\n};\nassertCustomType(v);\n```\n\nThis library also comes with a combinator to transform an assertion functions into a [type guard function](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards):\n```ts\nconst checkNumber = t.check(t.isNumber);\ncheckNumber(1) === true;\ncheckNumber(\"\") === false;\n```\n\nIt is especially convenient when combined with functional operations such as `Array#filter`:\n```ts\nconst t = [\"a\", 3, \"c\", 4, null, 2]\n  .filter(t.check(t.isNumber))\n  .map(x => x % 2 === 0 ? x : null) // x: number\n  .filter(t.check(t.isNotNull));\n// t: number[] = [4, 2]\n```\n\nTo encourage using asserts when dealing with untrusted JSON input, the following function is also exported:\n```ts\nexport const safeJsonParse = (json: string): unknown =>\n  JSON.parse(json) as unknown;\n```\n\n### Configuration\n\nThis library is designed to work in the browser as well as in Node without external dependencies, and by default does not use the `assert` module from the Node stdlib, so it ships with a very basic `assert` implementation:\n```ts\nexport type WeakAssert = (input: unknown, message?: string) => void;\n\nexport const defaultAssert: WeakAssert = (condition, message) => {\n  if (!condition) {\n    throw new TypeError(message);\n  }\n};\n\n```\n\nIt is however possible to configure the library to use a provided base `assert` function, such as the native `assert` module:\n```ts\nimport * as t from \"typed-assert\";\nimport nodeAssert from \"assert\";\n\nt.setBaseAssert(nodeAssert);\n```\n\n### Caveats\n\nDue to limitations in the typechecker, there are syntactic restrictions in how to define and use type assertion functions. For example, you can not dynamically define an assertion function, even if it looks like a static definition.\n\nThus the following code won't compile:\n```ts\nfunction createIsExactly<T>(value: T): (input: unknown) => asserts input is T {\n  return function isExactly(input: unknown): asserts input is T {\n    t.isExactly(input, value);\n  };\n}\n// No problem so far\n\ncreateIsExactly(\"a\")(null);\n// Won't compile:\n// Assertions require the call target to be an\n//  identifier or qualified name.ts(2776)\n```\n\nFor similar reasons, it is not possible to use type-inferred arrow functions to define assertion functions:\n```ts\nconst isExactlyNull = (input: unknown): asserts input is null => assert(input === value);\n// No problem so far\n\nisExactlyNull(\"a\", null):\n// Won't compile:\n// Assertions require the call target to be an\n//  identifier or qualified name.ts(2776)\n```\n\nIt is however possible to use arrow function with explicit typing of the left-hand operand:\n```ts\nconst isExactlyNull: (input: unknown) => asserts input is null = (input) =>\n  assert(input === null);\n\nisExactlyNull(\"a\");\n// No problem\n```\n\nTo simplify the implementation,\n\nTo simplify this pattern, this library also exports the `Assert<Input, Output>` type as defined below:\n```ts\nexport type Assert<T> = (\n  input: unknown,\n  message?: string,\n) => asserts input is T;\n\nconst isExactlyNull: Assert<null> = (input) => assert(input === null);\n\nisExactlyNull(\"a\");\n// No problem\n```\n\nFor convenience, this library also exports the following types, used internally:\n\n```ts\nexport type WeakAssert = (input: unknown, message?: string) => void;\n\nexport type SubType<Input, Output> = Output extends Input ? Output : never;\n\nexport type Assert<Input = unknown, Output = Input> = (\n  input: Input,\n  message?: string,\n) => asserts input is SubType<Input, Output>;\n\nexport type Check<Input = unknown, Output = Input> = (\n  input: Input,\n) => input is SubType<Input, Output>;\n```\n\nThis way we can write:\n```ts\nconst isExactlyNull: Assert<unknown, null> = (input) =>\n  assert(input === null);\n\nisExactlyNull(\"a\");\n```\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/typed-assert/-/typed-assert-1.0.9.tgz#8af9d4f93432c4970ec717e3006f33f135b06213",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/typed-assert/-/typed-assert-1.0.9.tgz",
    "hash": "8af9d4f93432c4970ec717e3006f33f135b06213",
    "integrity": "sha512-KNNZtayBCtmnNmbo5mG47p1XsCyrx6iVqomjcZnec/1Y5GGARaxPs6r49RnSPeUP3YjNYiU9sQHAtY4BBvnZwg==",
    "registry": "npm",
    "packageName": "typed-assert",
    "cacheIntegrity": "sha512-KNNZtayBCtmnNmbo5mG47p1XsCyrx6iVqomjcZnec/1Y5GGARaxPs6r49RnSPeUP3YjNYiU9sQHAtY4BBvnZwg== sha1-ivnU+TQyxJcOxxfjAG8z8TWwYhM="
  },
  "registry": "npm",
  "hash": "8af9d4f93432c4970ec717e3006f33f135b06213"
}