{
  "manifest": {
    "name": "@sinclair/typebox",
    "version": "0.27.8",
    "description": "JSONSchema Type Builder with Static Type Resolution for TypeScript",
    "keywords": [
      "typescript",
      "json-schema",
      "validate",
      "typecheck"
    ],
    "author": {
      "name": "sinclairzx81"
    },
    "license": "MIT",
    "main": "./typebox.js",
    "types": "./typebox.d.ts",
    "exports": {
      "./compiler": "./compiler/index.js",
      "./errors": "./errors/index.js",
      "./system": "./system/index.js",
      "./value": "./value/index.js",
      ".": "./typebox.js"
    },
    "repository": {
      "type": "git",
      "url": "https://github.com/sinclairzx81/typebox"
    },
    "scripts": {
      "clean": "hammer task clean",
      "format": "hammer task format",
      "start": "hammer task start",
      "test": "hammer task test",
      "benchmark": "hammer task benchmark",
      "build": "hammer task build",
      "publish": "hammer task publish"
    },
    "devDependencies": {
      "@sinclair/hammer": "^0.17.1",
      "@types/chai": "^4.3.3",
      "@types/mocha": "^9.1.1",
      "@types/node": "^18.11.9",
      "ajv": "^8.12.0",
      "ajv-formats": "^2.1.1",
      "chai": "^4.3.6",
      "mocha": "^9.2.2",
      "prettier": "^2.7.1",
      "typescript": "^5.0.2"
    },
    "_registry": "npm",
    "_loc": "/home/runner/website-breaker2/.cache/yarn/v6/npm-@sinclair-typebox-0.27.8-6667fac16c436b5434a387a34dedb013198f6e6e-integrity/node_modules/@sinclair/typebox/package.json",
    "readmeFilename": "readme.md",
    "readme": "<div align='center'>\n\n<h1>TypeBox</h1>\n\n<p>JSON Schema Type Builder with Static Type Resolution for TypeScript</p>\n\t\n<img src=\"https://github.com/sinclairzx81/typebox/blob/master/typebox.png?raw=true\" />\n\n<br />\n<br />\n\n[![npm version](https://badge.fury.io/js/%40sinclair%2Ftypebox.svg)](https://badge.fury.io/js/%40sinclair%2Ftypebox)\n[![Downloads](https://img.shields.io/npm/dm/%40sinclair%2Ftypebox.svg)](https://www.npmjs.com/package/%40sinclair%2Ftypebox)\n[![GitHub CI](https://github.com/sinclairzx81/typebox/workflows/GitHub%20CI/badge.svg)](https://github.com/sinclairzx81/typebox/actions)\n\n</div>\n\n<a name=\"Install\"></a>\n\n## Install\n\n#### Npm\n```bash\n$ npm install @sinclair/typebox --save\n```\n\n#### Deno\n```typescript\nimport { Static, Type } from 'npm:@sinclair/typebox'\n```\n\n#### Esm\n\n```typescript\nimport { Static, Type } from 'https://esm.sh/@sinclair/typebox'\n```\n\n## Example\n\n```typescript\nimport { Static, Type } from '@sinclair/typebox'\n\nconst T = Type.Object({                              // const T = {\n  x: Type.Number(),                                  //   type: 'object',\n  y: Type.Number(),                                  //   required: ['x', 'y', 'z'],\n  z: Type.Number()                                   //   properties: {\n})                                                   //     x: { type: 'number' },\n                                                     //     y: { type: 'number' },\n                                                     //     z: { type: 'number' }\n                                                     //   }\n                                                     // }\n\ntype T = Static<typeof T>                            // type T = {\n                                                     //   x: number,\n                                                     //   y: number,\n                                                     //   z: number\n                                                     // }\n```\n\n\n<a name=\"Overview\"></a>\n\n## Overview\n\nTypeBox is a runtime type builder that creates in-memory JSON Schema objects that can be statically inferred as TypeScript types. The schemas produced by this library are designed to match the static type assertion rules of the TypeScript compiler. TypeBox enables one to create a unified type that can be statically checked by TypeScript and runtime asserted using standard JSON Schema validation.\n\nThis library is designed to enable JSON schema to compose with the same flexibility as TypeScript's type system. It can be used as a simple tool to build up complex schemas or integrated into REST or RPC services to help validate data received over the wire. \n\nLicense MIT\n\n## Contents\n- [Install](#install)\n- [Overview](#overview)\n- [Usage](#usage)\n- [Types](#types)\n  - [Standard](#types-standard)\n  - [Extended](#types-extended)\n  - [Modifiers](#types-modifiers)\n  - [Options](#types-options)\n  - [Generics](#types-generics)\n  - [References](#types-references)\n  - [Recursive](#types-recursive)\n  - [Conditional](#types-conditional)\n  - [Template Literal](#types-template-literal)\n  - [Guards](#types-guards)\n  - [Unsafe](#types-unsafe)\n  - [Strict](#types-strict)\n- [Values](#values)\n  - [Create](#values-create)\n  - [Clone](#values-clone)\n  - [Check](#values-check)\n  - [Convert](#values-convert)\n  - [Cast](#values-cast)\n  - [Equal](#values-equal)\n  - [Hash](#values-hash)\n  - [Diff](#values-diff)\n  - [Patch](#values-patch)\n  - [Errors](#values-errors)\n  - [Mutate](#values-mutate)\n  - [Pointer](#values-pointer)\n- [TypeCheck](#typecheck)\n  - [Ajv](#typecheck-ajv)\n  - [TypeCompiler](#typecheck-typecompiler)\n- [TypeSystem](#typesystem)\n  - [Types](#typesystem-types)\n  - [Formats](#typesystem-formats)\n  - [Policies](#typesystem-policies)\n- [Benchmark](#benchmark)\n  - [Compile](#benchmark-compile)\n  - [Validate](#benchmark-validate)\n  - [Compression](#benchmark-compression)\n- [Contribute](#contribute)\n\n<a name=\"usage\"></a>\n\n## Usage\n\nThe following shows general usage.\n\n```typescript\nimport { Static, Type } from '@sinclair/typebox'\n\n//--------------------------------------------------------------------------------------------\n//\n// Let's say you have the following type ...\n//\n//--------------------------------------------------------------------------------------------\n\ntype T = {\n  id: string,\n  name: string,\n  timestamp: number\n}\n\n//--------------------------------------------------------------------------------------------\n//\n// ... you can express this type in the following way.\n//\n//--------------------------------------------------------------------------------------------\n\nconst T = Type.Object({                              // const T = {\n  id: Type.String(),                                 //   type: 'object',\n  name: Type.String(),                               //   properties: { \n  timestamp: Type.Integer()                          //     id: { \n})                                                   //       type: 'string' \n                                                     //     },\n                                                     //     name: { \n                                                     //       type: 'string' \n                                                     //     },\n                                                     //     timestamp: { \n                                                     //       type: 'integer' \n                                                     //     }\n                                                     //   }, \n                                                     //   required: [\n                                                     //     'id',\n                                                     //     'name',\n                                                     //     'timestamp'\n                                                     //   ]\n                                                     // } \n\n//--------------------------------------------------------------------------------------------\n//\n// ... then infer back to the original static type this way.\n//\n//--------------------------------------------------------------------------------------------\n\ntype T = Static<typeof T>                            // type T = {\n                                                     //   id: string,\n                                                     //   name: string,\n                                                     //   timestamp: number\n                                                     // }\n\n//--------------------------------------------------------------------------------------------\n//\n// ... then use the type both as JSON schema and as a TypeScript type.\n//\n//--------------------------------------------------------------------------------------------\n\nimport { Value } from '@sinclair/typebox/value'\n\nfunction receive(value: T) {                         // ... as a Static Type\n\n  if(Value.Check(T, value)) {                        // ... as a JSON Schema\n  \n    // ok...\n  }\n}\n```\n\n<a name='types'></a>\n\n## Types\n\nTypeBox types are JSON schema fragments that can be composed into more complex types. Each fragment is structured such that a JSON schema compliant validator can runtime assert a value the same way TypeScript will statically assert a type. TypeBox provides a set of Standard types which are used create JSON schema compliant schematics as well as an Extended type set used to create schematics for constructs native to JavaScript. \n\n<a name='types-standard'></a>\n\n### Standard Types\n\nThe following table lists the Standard TypeBox types. These types are fully compatible with the JSON Schema Draft 6 specification.\n\n```typescript\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\n│ TypeBox                        │ TypeScript                  │ JSON Schema                    │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Any()           │ type T = any                │ const T = { }                  │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Unknown()       │ type T = unknown            │ const T = { }                  │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.String()        │ type T = string             │ const T = {                    │\n│                                │                             │   type: 'string'               │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Number()        │ type T = number             │ const T = {                    │\n│                                │                             │   type: 'number'               │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Integer()       │ type T = number             │ const T = {                    │\n│                                │                             │   type: 'integer'              │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Boolean()       │ type T = boolean            │ const T = {                    │\n│                                │                             │   type: 'boolean'              │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Null()          │ type T = null               │ const T = {                    │\n│                                │                             │   type: 'null'                 │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Literal(42)     │ type T = 42                 │ const T = {                    │\n│                                │                             │   const: 42,                   │\n│                                │                             │   type: 'number'               │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Array(          │ type T = number[]           │ const T = {                    │\n│   Type.Number()                │                             │   type: 'array',               │\n│ )                              │                             │   items: {                     │\n│                                │                             │     type: 'number'             │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\n│   x: Type.Number(),            │   x: number,                │   type: 'object',              │\n│   y: Type.Number()             │   y: number                 │   required: ['x', 'y'],        │\n│ })                             │ }                           │   properties: {                │\n│                                │                             │     x: {                       │\n│                                │                             │       type: 'number'           │\n│                                │                             │     }, {                       │\n│                                │                             │       type: 'number'           │\n│                                │                             │     }                          │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Tuple([         │ type T = [number, number]   │ const T = {                    │\n│   Type.Number(),               │                             │   type: 'array',               │\n│   Type.Number()                │                             │   items: [{                    │\n│ ])                             │                             │      type: 'number'            │\n│                                │                             │   }, {                         │\n│                                │                             │     type: 'number'             │\n│                                │                             │   }],                          │\n│                                │                             │   additionalItems: false,      │\n│                                │                             │   minItems: 2,                 │\n│                                │                             │   maxItems: 2                  │\n│                                │                             │ }                              │\n│                                │                             │                                │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ enum Foo {                     │ enum Foo {                  │ const T = {                    │\n│   A,                           │   A,                        │   anyOf: [{                    │\n│   B                            │   B                         │     type: 'number',            │\n│ }                              │ }                           │     const: 0                   │\n│                                │                             │   }, {                         │\n│ const T = Type.Enum(Foo)       │ type T = Foo                │     type: 'number',            │\n│                                │                             │     const: 1                   │\n│                                │                             │   }]                           │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.KeyOf(          │ type T = keyof {            │ const T = {                    │\n│   Type.Object({                │   x: number,                │   anyOf: [{                    │\n│     x: Type.Number(),          │   y: number                 │     type: 'string',            │\n│     y: Type.Number()           │ }                           │     const: 'x'                 │\n│   })                           │                             │   }, {                         │\n│ )                              │                             │     type: 'string',            │\n│                                │                             │     const: 'y'                 │\n│                                │                             │   }]                           │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Union([         │ type T = string | number    │ const T = {                    │\n│   Type.String(),               │                             │   anyOf: [{                    │\n│   Type.Number()                │                             │      type: 'string'            │\n│ ])                             │                             │   }, {                         │\n│                                │                             │      type: 'number'            │\n│                                │                             │   }]                           │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Intersect([     │ type T = {                  │ const T = {                    │\n│   Type.Object({                │   x: number                 │   allOf: [{                    │\n│     x: Type.Number()           │ } & {                       │     type: 'object',            │\n│   }),                          │   y: number                 │     required: ['x'],           │\n│   Type.Object({                │ }                           │     properties: {              │\n│     y: Type.Number()           │                             │       x: {                     │\n│   ])                           │                             │         type: 'number'         │\n│ ])                             │                             │       }                        │\n│                                │                             │     }                          │\n│                                │                             │   }, {                         │\n│                                │                             │     type: 'object',            |\n│                                │                             │     required: ['y'],           │\n│                                │                             │     properties: {              │\n│                                │                             │       y: {                     │\n│                                │                             │         type: 'number'         │\n│                                │                             │       }                        │\n│                                │                             │     }                          │\n│                                │                             │   }]                           │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Composite([     │ type I = {                  │ const T = {                    │\n│   Type.Object({                │   x: number                 │   type: 'object',              │\n│     x: Type.Number()           │ } & {                       │   required: ['x', 'y'],        │\n│   }),                          │   y: number                 │   properties: {                │\n│   Type.Object({                │ }                           │     x: {                       │\n│     y: Type.Number()           │                             │       type: 'number'           │\n│   })                           │ type T = {                  │     },                         │\n│ ])                             │   [K in keyof I]: I[K]      │     y: {                       │\n│                                │ }                           │       type: 'number'           │\n│                                │                             │     }                          │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Never()         │ type T = never              │ const T = {                    │\n│                                │                             │   not: {}                      │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Not(            | type T = string             │ const T = {                    │\n|   Type.Union([                 │                             │   allOf: [{                    │\n│     Type.Literal('x'),         │                             │     not: {                     │\n│     Type.Literal('y'),         │                             │       anyOf: [                 │\n│     Type.Literal('z')          │                             │         { const: 'x' },        │\n│   ]),                          │                             │         { const: 'y' },        │\n│   Type.String()                │                             │         { const: 'z' }         │\n│ )                              │                             │       ]                        │\n│                                │                             │     }                          │\n│                                │                             │   }, {                         │\n│                                │                             │     type: 'string'             │\n│                                │                             │   }]                           │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Extends(        │ type T =                    │ const T = {                    │\n│   Type.String(),               │  string extends number      │   const: false,                │\n│   Type.Number(),               │  true : false               │   type: 'boolean'              │\n│   Type.Literal(true),          │                             │ }                              │\n│   Type.Literal(false)          │                             │                                │\n│ )                              │                             │                                │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Extract(        │ type T = Extract<           │ const T = {                    │\n│   Type.Union([                 │   string | number,          │   type: 'string'               │\n│     Type.String(),             │   string                    │ }                              │\n│     Type.Number(),             │ >                           │                                │\n│   ]),                          │                             │                                │\n│   Type.String()                │                             │                                │\n│ )                              │                             │                                │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Exclude(        │ type T = Exclude<           │ const T = {                    │\n│   Type.Union([                 │   string | number,          │   type: 'number'               │\n│     Type.String(),             │   string                    │ }                              │\n│     Type.Number(),             │ >                           │                                │\n│   ]),                          │                             │                                │\n│   Type.String()                │                             │                                │\n│ )                              │                             │                                │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const U = Type.Union([         │ type U = 'open' | 'close'   │ const T = {                    │\n│   Type.Literal('open'),        │                             │   type: 'string',              │\n│   Type.Literal('close')        │ type T = `on${U}`           │   pattern: '^on(open|close)$'  │\n│ ])                             │                             │ }                              │\n│                                │                             │                                │\n│ const T = Type                 │                             │                                │\n│   .TemplateLiteral([           │                             │                                │\n│      Type.Literal('on'),       │                             │                                │\n│      U                         │                             │                                │\n│   ])                           │                             │                                │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Record(         │ type T = Record<            │ const T = {                    │\n│   Type.String(),               │   string,                   │   type: 'object',              │\n│   Type.Number()                │   number                    │   patternProperties: {         │\n│ )                              │ >                           │     '^.*$': {                  │\n│                                │                             │       type: 'number'           │\n│                                │                             │     }                          │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Partial(        │ type T = Partial<{          │ const T = {                    │\n│   Type.Object({                │   x: number,                │   type: 'object',              │\n│     x: Type.Number(),          │   y: number                 │   properties: {                │\n│     y: Type.Number()           | }>                          │     x: {                       │\n│   })                           │                             │       type: 'number'           │\n│ )                              │                             │     },                         │\n│                                │                             │     y: {                       │\n│                                │                             │       type: 'number'           │\n│                                │                             │     }                          │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Required(       │ type T = Required<{         │ const T = {                    │\n│   Type.Object({                │   x?: number,               │   type: 'object',              │\n│     x: Type.Optional(          │   y?: number                │   required: ['x', 'y'],        │\n│       Type.Number()            | }>                          │   properties: {                │\n│     ),                         │                             │     x: {                       │\n│     y: Type.Optional(          │                             │       type: 'number'           │\n│       Type.Number()            │                             │     },                         │\n│     )                          │                             │     y: {                       │\n│   })                           │                             │       type: 'number'           │\n│ )                              │                             │     }                          │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Pick(           │ type T = Pick<{             │ const T = {                    │\n│   Type.Object({                │   x: number,                │   type: 'object',              │\n│     x: Type.Number(),          │   y: number                 │   required: ['x'],             │\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\n│   }), ['x']                    |                             │     x: {                       │\n│ )                              │                             │       type: 'number'           │\n│                                │                             │     }                          │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Omit(           │ type T = Omit<{             │ const T = {                    │\n│   Type.Object({                │   x: number,                │   type: 'object',              │\n│     x: Type.Number(),          │   y: number                 │   required: ['y'],             │\n│     y: Type.Number()           │ }, 'x'>                     │   properties: {                │\n│   }), ['x']                    |                             │     y: {                       │\n│ )                              │                             │       type: 'number'           │\n│                                │                             │     }                          │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Object({        │ type T = {                  │ const R = {                    │\n│    x: Type.Number(),           │   x: number,                │   $ref: 'T'                    │\n│    y: Type.Number()            │   y: number                 │ }                              │\n│ }, { $id: 'T' })               | }                           │                                │\n│                                │                             │                                │\n│ const R = Type.Ref(T)          │ type R = T                  │                                │\n│                                │                             │                                │\n│                                │                             │                                │\n│                                │                             │                                │\n│                                │                             │                                │\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\n```\n\n<a name='types-extended'></a>\n\n### Extended Types\n\nTypeBox provides several extended types that can be used to produce schematics for common JavaScript constructs. These types can not be used with standard JSON schema validators; but are useful to help frame schematics for RPC interfaces that may receive JSON validated data. Extended types are prefixed with the `[Extended]` doc comment for convenience. The following table lists the supported types.\n\n```typescript\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\n│ TypeBox                        │ TypeScript                  │ Extended Schema                │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Constructor([   │ type T = new (              │ const T = {                    │\n│   Type.String(),               │  arg0: string,              │   type: 'object',              │\n│   Type.Number()                │  arg1: number               │   instanceOf: 'Constructor',   │\n│ ], Type.Boolean())             │ ) => boolean                │   parameters: [{               │\n│                                │                             │     type: 'string'             │\n│                                │                             │   }, {                         │\n│                                │                             │     type: 'number'             │\n│                                │                             │   }],                          │\n│                                │                             │   return: {                    │\n│                                │                             │     type: 'boolean'            │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Function([      │ type T = (                  │ const T = {                    │\n|   Type.String(),               │  arg0: string,              │   type : 'object',             │\n│   Type.Number()                │  arg1: number               │   instanceOf: 'Function',      │\n│ ], Type.Boolean())             │ ) => boolean                │   parameters: [{               │\n│                                │                             │     type: 'string'             │\n│                                │                             │   }, {                         │\n│                                │                             │     type: 'number'             │\n│                                │                             │   }],                          │\n│                                │                             │   return: {                    │\n│                                │                             │     type: 'boolean'            │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Promise(        │ type T = Promise<string>    │ const T = {                    │\n│   Type.String()                │                             │   type: 'object',              │\n│ )                              │                             │   instanceOf: 'Promise',       │\n│                                │                             │   item: {                      │\n│                                │                             │     type: 'string'             │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Uint8Array()    │ type T = Uint8Array         │ const T = {                    │\n│                                │                             │   type: 'object',              │\n│                                │                             │   instanceOf: 'Uint8Array'     │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Date()          │ type T = Date               │ const T = {                    │\n│                                │                             │   type: 'object',              │\n│                                │                             │   instanceOf: 'Date'           │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Undefined()     │ type T = undefined          │ const T = {                    │\n│                                │                             │   type: 'null',                │\n│                                │                             │   typeOf: 'Undefined'          │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.RegEx(/foo/)    │ type T = string             │ const T = {                    │\n│                                │                             │    type: 'string',             │\n│                                │                             │    pattern: 'foo'              │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Symbol()        │ type T = symbol             │ const T = {                    │\n│                                │                             │   type: 'null',                │\n│                                │                             │   typeOf: 'Symbol'             │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.BigInt()        │ type T = bigint             │ const T = {                    │\n│                                │                             │   type: 'null',                │\n│                                │                             │   typeOf: 'BigInt'             │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Void()          │ type T = void               │ const T = {                    │\n│                                │                             │   type: 'null'                 │\n│                                │                             │   typeOf: 'Void'               │\n│                                │                             │ }                              │\n│                                │                             │                                │\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\n```\n\n<a name='types-modifiers'></a>\n\n### Modifiers\n\nTypeBox provides modifiers that allow schema properties to be statically inferred as `readonly` or `optional`. The following table shows the supported modifiers and how they map between TypeScript and JSON Schema.\n\n```typescript\n┌────────────────────────────────┬─────────────────────────────┬────────────────────────────────┐\n│ TypeBox                        │ TypeScript                  │ JSON Schema                    │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\n│   name: Type.Optional(         │   name?: string             │   type: 'object',              │\n│     Type.String()              │ }                           │   properties: {                │\n│   )                            │                             │     name: {                    │\n│ })  \t                         │                             │       type: 'string'           │\n│                                │                             │     }                          │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\n│   name: Type.Readonly(         │   readonly name: string     │   type: 'object',              │\n│     Type.String()              │ }                           │   properties: {                │\n│   )                            │                             │     name: {                    │\n│ })  \t                         │                             │       type: 'string'           │\n│                                │                             │     }                          │\n│                                │                             │   },                           │\n│                                │                             │   required: ['name']           │\n│                                │                             │ }                              │\n│                                │                             │                                │\n├────────────────────────────────┼─────────────────────────────┼────────────────────────────────┤\n│ const T = Type.Object({        │ type T = {                  │ const T = {                    │\n│   name: Type.ReadonlyOptional( │   readonly name?: string    │   type: 'object',              │\n│     Type.String()              │ }                           │   properties: {                │\n│   )                            │                             │     name: {                    │\n│ })  \t                         │                             │       type: 'string'           │\n│                                │                             │     }                          │\n│                                │                             │   }                            │\n│                                │                             │ }                              │\n│                                │                             │                                │\n└────────────────────────────────┴─────────────────────────────┴────────────────────────────────┘\n```\n\n<a name='types-options'></a>\n\n### Options\n\nYou can pass JSON Schema options on the last argument of any type. Option hints specific to each type are provided for convenience.\n\n```typescript\n// String must be an email\nconst T = Type.String({                              // const T = { \n  format: 'email'                                    //   type: 'string',\n})                                                   //   format: 'email' \n                                                     // }\n\n// Mumber must be a multiple of 2\nconst T = Type.Number({                              // const T = { \n  multipleOf: 2                                      //  type: 'number', \n})                                                   //  multipleOf: 2 \n                                                     // }\n\n// Array must have at least 5 integer values\nconst T = Type.Array(Type.Integer(), {               // const T = { \n  minItems: 5                                        //   type: 'array',\n})                                                   //   minItems: 5,        \n                                                     //   items: { \n                                                     //     type: 'integer'\n                                                     //   }\n                                                     // }\n\n```\n\n<a name='types-generics'></a>\n\n### Generic Types\n\nGeneric types can be created with generic functions constrained to type `TSchema`. The following creates a generic `Vector<T>` type.\n\n```typescript\nimport { Type, Static, TSchema } from '@sinclair/typebox'\n\nconst Vector = <T extends TSchema>(t: T) => Type.Object({ x: t, y: t, z: t })\n\nconst NumberVector = Vector(Type.Number())           // const NumberVector = {\n                                                     //   type: 'object',\n                                                     //   required: ['x', 'y', 'z'],\n                                                     //   properties: {\n                                                     //     x: { type: 'number' },\n                                                     //     y: { type: 'number' },\n                                                     //     z: { type: 'number' }\n                                                     //   }\n                                                     // }\n\ntype NumberVector = Static<typeof NumberVector>      // type NumberVector = {\n                                                     //   x: number,\n                                                     //   y: number,\n                                                     //   z: number\n                                                     // }\n\nconst BooleanVector = Vector(Type.Boolean())         // const BooleanVector = {\n                                                     //   type: 'object',\n                                                     //   required: ['x', 'y', 'z'],\n                                                     //   properties: {\n                                                     //     x: { type: 'boolean' },\n                                                     //     y: { type: 'boolean' },\n                                                     //     z: { type: 'boolean' }\n                                                     //   }\n                                                     // }\n\ntype BooleanVector = Static<typeof BooleanVector>    // type BooleanVector = {\n                                                     //   x: boolean,\n                                                     //   y: boolean,\n                                                     //   z: boolean\n                                                     // }\n```\n\nThe following creates a generic `Nullable<T>` type.\n\n```typescript\nconst Nullable = <T extends TSchema>(schema: T) => Type.Union([schema, Type.Null()])\n\nconst T = Nullable(Type.String())                   // const T = {\n                                                    //   anyOf: [\n                                                    //     { type: 'string' },\n                                                    //     { type: 'null' }\n                                                    //   ]\n                                                    // }\n\ntype T = Static<typeof T>                           // type T = string | null\n```\n\n<a name='types-references'></a>\n\n### Reference Types\n\nReference types are supported with `Type.Ref`. The target type must specify a valid `$id`.\n\n```typescript\nconst T = Type.String({ $id: 'T' })                  // const T = {\n                                                     //    $id: 'T',\n                                                     //    type: 'string'\n                                                     // }\n                                             \nconst R = Type.Ref(T)                                // const R = {\n                                                     //    $ref: 'T'\n                                                     // }\n```\n\n<a name='types-recursive'></a>\n\n### Recursive Types\n\nRecursive types are supported with `Type.Recursive`\n\n```typescript\nconst Node = Type.Recursive(Node => Type.Object({    // const Node = {\n  id: Type.String(),                                 //   $id: 'Node',\n  nodes: Type.Array(Node)                            //   type: 'object',\n}), { $id: 'Node' })                                 //   properties: {\n                                                     //     id: {\n                                                     //       type: 'string'\n                                                     //     },\n                                                     //     nodes: {\n                                                     //       type: 'array',\n                                                     //       items: {\n                                                     //         $ref: 'Node'\n                                                     //       }\n                                                     //     }\n                                                     //   },\n                                                     //   required: [\n                                                     //     'id',\n                                                     //     'nodes'\n                                                     //   ]\n                                                     // }\n\ntype Node = Static<typeof Node>                      // type Node = {\n                                                     //   id: string\n                                                     //   nodes: Node[]\n                                                     // }\n\nfunction test(node: Node) {\n  const id = node.nodes[0].nodes[0].id               // id is string\n}\n```\n\n<a name='types-conditional'></a>\n\n### Conditional Types\n\nConditional types are supported with `Type.Extends`, `Type.Exclude` and `Type.Extract`\n\n```typescript\n// TypeScript\n\ntype T0 = string extends number ? true : false       // type T0 = false\n\ntype T1 = Extract<string | number, number>           // type T1 = number\n\ntype T2 = Exclude<string | number, number>           // type T2 = string\n\n// TypeBox\n\nconst T0 = Type.Extends(Type.String(), Type.Number(), Type.Literal(true), Type.Literal(false))\n\nconst T1 = Type.Extract(Type.Union([Type.String(), Type.Number()]), Type.Number())\n\nconst T2 = Type.Exclude(Type.Union([Type.String(), Type.Number()]), Type.Number())\n\n\ntype T0 = Static<typeof T0>                        // type T0 = false\n\ntype T1 = Static<typeof T1>                        // type T1 = number\n\ntype T2 = Static<typeof T2>                        // type T2 = string \n```\n\n<a name='types-template-literal'></a>\n\n### Template Literal Types\n\nTemplate Literal types are supported with `Type.TemplateLiteral`\n\n```typescript\n// TypeScript\n\ntype T = `option${'A'|'B'}`                          // type T = 'optionA' | 'optionB'\n\ntype R = Record<T, string>                           // type R = {\n                                                     //   optionA: string\n                                                     //   optionB: string\n                                                     // }\n\n// TypeBox\n\nconst T = Type.TemplateLiteral([                     // const T = {\n  Type.Literal('option'),                            //   pattern: '^option(A|B)$',\n  Type.Union([                                       //   type: 'string'\n    Type.Literal('A'),                               // }\n    Type.Literal('B')\n  ])\n])\n\nconst R = Type.Record(T, Type.String())              // const R = {\n                                                     //   type: 'object',\n                                                     //   required: ['optionA', 'optionB'],\n                                                     //   properties: {\n                                                     //     optionA: {\n                                                     //       type: 'string'\n                                                     //     },\n                                                     //     optionB: {\n                                                     //       type: 'string'\n                                                     //     }\n                                                     //   }\n                                                     // }\n\ntype T = Static<typeof T>                            // type T = 'optionA' | 'optionB'\n\ntype R = Static<typeof R>                            // type R = {\n                                                     //   optionA: string\n                                                     //   optionB: string\n                                                     // }\n```\n\n<a name='types-unsafe'></a>\n\n### Unsafe\n\nUse `Type.Unsafe` to create custom schematics with user defined inference rules.\n\n```typescript\nconst T = Type.Unsafe<string>({ type: 'number' })    // const T = {\n                                                     //   type: 'number'\n                                                     // }\n\ntype T = Static<typeof T>                            // type T = string\n```\n\nThe `Type.Unsafe` type can be useful to express specific OpenAPI schema representations.\n\n```typescript\nimport { Type, Static, TSchema } from '@sinclair/typebox'\n\n// Nullable<T>\n\nfunction Nullable<T extends TSchema>(schema: T) {\n  return Type.Unsafe<Static<T> | null>({ ...schema, nullable: true })\n}\n\nconst T = Nullable(Type.String())                    // const T = {\n                                                     //   type: 'string',\n                                                     //   nullable: true\n                                                     // }\n\ntype T = Static<typeof T>                            // type T = string | null\n\n// StringEnum<string[]>\n\nfunction StringEnum<T extends string[]>(values: [...T]) {\n  return Type.Unsafe<T[number]>({ type: 'string', enum: values })\n}\n\nconst T = StringEnum(['A', 'B', 'C'])                // const T = {\n                                                     //   enum: ['A', 'B', 'C']\n                                                     // }\n\ntype T = Static<typeof T>                            // type T = 'A' | 'B' | 'C'\n```\n\n<a name='types-guards'></a>\n\n### Guards\n\nTypeBox provides a `TypeGuard` module that can be used for reflection and asserting values as types.\n\n```typescript\nimport { Type, TypeGuard } from '@sinclair/typebox'\n\nconst T = Type.String()\n\nif(TypeGuard.TString(T)) {\n    \n  // T is TString\n}\n```\n\n<a name='types-strict'></a>\n\n### Strict\n\nTypeBox schemas contain the `Kind` and `Modifier` symbol properties. These properties are used for type composition and reflection. These properties are not strictly valid JSON schema; so in some cases it may be desirable to omit them. TypeBox provides a `Type.Strict` function that will omit these properties if necessary.\n\n```typescript\nconst T = Type.Object({                              // const T = {\n  name: Type.Optional(Type.String())                 //   [Kind]: 'Object',\n})                                                   //   type: 'object',\n                                                     //   properties: {\n                                                     //     name: {\n                                                     //       [Kind]: 'String',\n                                                     //       type: 'string',\n                                                     //       [Modifier]: 'Optional'\n                                                     //     }\n                                                     //   }\n                                                     // }\n\nconst U = Type.Strict(T)                             // const U = {\n                                                     //   type: 'object', \n                                                     //   properties: { \n                                                     //     name: { \n                                                     //       type: 'string' \n                                                     //     } \n                                                     //   } \n                                                     // }\n```\n\n<a name='values'></a>\n\n## Values\n\nTypeBox provides an optional utility module that can be used to perform common operations on JavaScript values. This module includes functionality to create, check and cast values from types as well as check equality, clone, diff and patch JavaScript values. This module is provided via optional import.\n\n```typescript\nimport { Value } from '@sinclair/typebox/value'\n```\n\n<a name='values-create'></a>\n\n### Create\n\nUse the Create function to create a value from a type. TypeBox will use default values if specified.\n\n```typescript\nconst T = Type.Object({ x: Type.Number(), y: Type.Number({ default: 42 }) })\n\nconst A = Value.Create(T)                            // const A = { x: 0, y: 42 }\n```\n\n<a name='values-clone'></a>\n\n### Clone\n\nUse the Clone function to deeply clone a value\n\n```typescript\nconst A = Value.Clone({ x: 1, y: 2, z: 3 })          // const A = { x: 1, y: 2, z: 3 }\n```\n\n<a name='values-check'></a>\n\n### Check\n\nUse the Check function to type check a value\n\n```typescript\nconst T = Type.Object({ x: Type.Number() })\n\nconst R = Value.Check(T, { x: 1 })                   // const R = true\n```\n\n<a name='values-convert'></a>\n\n### Convert\n\nUse the Convert function to convert a value into its target type if a reasonable conversion is possible.\n\n```typescript\nconst T = Type.Object({ x: Type.Number() })\n\nconst R1 = Value.Convert(T, { x: '3.14' })          // const R1 = { x: 3.14 }\n\nconst R2 = Value.Convert(T, { x: 'not a number' })  // const R2 = { x: 'not a number' }\n```\n\n<a name='values-cast'></a>\n\n### Cast\n\nUse the Cast function to cast a value into a type. The cast function will retain as much information as possible from the original value.\n\n```typescript\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() }, { additionalProperties: false })\n\nconst X = Value.Cast(T, null)                        // const X = { x: 0, y: 0 }\n\nconst Y = Value.Cast(T, { x: 1 })                    // const Y = { x: 1, y: 0 }\n\nconst Z = Value.Cast(T, { x: 1, y: 2, z: 3 })        // const Z = { x: 1, y: 2 }\n```\n\n<a name='values-equal'></a>\n\n### Equal\n\nUse the Equal function to deeply check for value equality.\n\n```typescript\nconst R = Value.Equal(                               // const R = true\n  { x: 1, y: 2, z: 3 },\n  { x: 1, y: 2, z: 3 }\n)\n```\n\n<a name='values-hash'></a>\n\n### Hash\n\nUse the Hash function to create a [FNV1A-64](https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function) non cryptographic hash of a value.\n\n```typescript\nconst A = Value.Hash({ x: 1, y: 2, z: 3 })          // const A = 2910466848807138541n\n\nconst B = Value.Hash({ x: 1, y: 4, z: 3 })          // const B = 1418369778807423581n\n```\n\n<a name='values-diff'></a>\n\n### Diff\n\nUse the Diff function to produce a sequence of edits to transform one value into another.\n\n```typescript\nconst E = Value.Diff(                               // const E = [\n  { x: 1, y: 2, z: 3 },                             //   { type: 'update', path: '/y', value: 4 },\n  { y: 4, z: 5, w: 6 }                              //   { type: 'update', path: '/z', value: 5 },\n)                                                   //   { type: 'insert', path: '/w', value: 6 },\n                                                    //   { type: 'delete', path: '/x' }\n                                                    // ]\n```\n\n<a name='values-patch'></a>\n\n### Patch\n\nUse the Patch function to apply edits\n\n```typescript\nconst A = { x: 1, y: 2 }\n\nconst B = { x: 3 }\n\nconst E = Value.Diff(A, B)                           // const E = [\n                                                     //   { type: 'update', path: '/x', value: 3 },\n                                                     //   { type: 'delete', path: '/y' }\n                                                     // ]\n\nconst C = Value.Patch<typeof B>(A, E)                // const C = { x: 3 }\n```\n\n<a name='values-errors'></a>\n\n### Errors\n\nUse the Errors function enumerate validation errors.\n\n```typescript\nconst T = Type.Object({ x: Type.Number(), y: Type.Number() })\n\nconst R = [...Value.Errors(T, { x: '42' })]          // const R = [{\n                                                     //   schema: { type: 'number' },\n                                                     //   path: '/x',\n                                                     //   value: '42',\n                                                     //   message: 'Expected number'\n                                                     // }, {\n                                                     //   schema: { type: 'number' },\n                                                     //   path: '/y',\n                                                     //   value: undefined,\n                                                     //   message: 'Expected number'\n                                                     // }]\n```\n\n<a name='values-mutate'></a>\n\n### Mutate\n\nUse the Mutate function to perform a deep mutable value assignment while retaining internal references.\n\n```typescript\nconst Y = { z: 1 }                                   // const Y = { z: 1 } \n\nconst X = { y: Y }                                   // const X = { y: { z: 1 } }\n\nconst A = { x: X }                                   // const A = { x: { y: { z: 1 } } }             \n\n\nValue.Mutate(A, { x: { y: { z: 2 } } })              // const A' = { x: { y: { z: 2 } } }   \n\nconst R0 = A.x.y.z === 2                             // const R0 = 2\n\nconst R1 = A.x.y === Y                               // const R1 = true\n\nconst R2 = A.x === X                                 // const R2 = true\n```     \n\n<a name='values-pointer'></a>\n\n### Pointer\n\nUse ValuePointer to perform mutable updates on existing values using [RFC6901](https://www.rfc-editor.org/rfc/rfc6901) JSON Pointers.\n\n```typescript\nimport { ValuePointer } from '@sinclair/typebox/value'\n\nconst A = { x: 0, y: 0, z: 0 }\n\nValuePointer.Set(A, '/x', 1)                         // const A' = { x: 1, y: 0, z: 0 }\n\nValuePointer.Set(A, '/y', 1)                         // const A' = { x: 1, y: 1, z: 0 }\n\nValuePointer.Set(A, '/z', 1)                         // const A' = { x: 1, y: 1, z: 1 }\n```\n\n<a name='typecheck'></a>\n\n## TypeCheck\n\nTypeBox types target JSON Schema draft 6 so are compatible with any validator that supports this specification. TypeBox also provides a built in type checking compiler designed specifically for high performance compilation and value assertion.\n\nThe following sections detail using Ajv and TypeBox's compiler infrastructure.\n\n<a name='typecheck-ajv'></a>\n\n## Ajv\n\nThe following shows the recommended setup for Ajv.\n\n```bash\n$ npm install ajv ajv-formats --save\n```\n\n```typescript\nimport { Type }   from '@sinclair/typebox'\nimport addFormats from 'ajv-formats'\nimport Ajv        from 'ajv'\n\nconst ajv = addFormats(new Ajv({}), [\n  'date-time', \n  'time', \n  'date', \n  'email',  \n  'hostname', \n  'ipv4', \n  'ipv6', \n  'uri', \n  'uri-reference', \n  'uuid',\n  'uri-template', \n  'json-pointer', \n  'relative-json-pointer', \n  'regex'\n])\n\nconst C = ajv.compile(Type.Object({                \n  x: Type.Number(),\n  y: Type.Number(),\n  z: Type.Number()\n}))\n\nconst R = C({ x: 1, y: 2, z: 3 })                    // const R = true \n```\n\n<a name='typecheck-typecompiler'></a>\n\n### TypeCompiler\n\nThe TypeBox TypeCompiler is a high performance JIT compiler that transforms TypeBox types into optimized JavaScript validation routines. The compiler is tuned for fast compilation as well as fast value assertion. It is designed to serve as a validation backend that can be integrated into larger applications; but can also be used as a general purpose validator.\n\nThe TypeCompiler is provided as an optional import.\n\n```typescript\nimport { TypeCompiler } from '@sinclair/typebox/compiler'\n```\n\nUse the `Compile(...)` function to compile a type.\n\n```typescript\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\n  x: Type.Number(),                                  //     x: TNumber;\n  y: Type.Number(),                                  //     y: TNumber;\n  z: Type.Number()                                   //     z: TNumber;\n}))                                                  // }>>\n\nconst R = C.Check({ x: 1, y: 2, z: 3 })              // const R = true\n```\n\nUse the `Errors(...)` function to produce diagnostic errors for a value. The `Errors(...)` function will return an iterator that if enumerated; will perform an exhaustive check across the entire value and yield any error found. For performance, this function should only be called after failed `Check(...)`. Applications may also choose to yield only the first value to avoid exhaustive error generation.\n\n```typescript\nconst C = TypeCompiler.Compile(Type.Object({         // const C: TypeCheck<TObject<{\n  x: Type.Number(),                                  //     x: TNumber;\n  y: Type.Number(),                                  //     y: TNumber;\n  z: Type.Number()                                   //     z: TNumber;\n}))                                                  // }>>\n\nconst value = { }\n\nconst errors = [...C.Errors(value)]                  // const errors = [{\n                                                     //   schema: { type: 'number' },\n                                                     //   path: '/x',\n                                                     //   value: undefined,\n                                                     //   message: 'Expected number'\n                                                     // }, {\n                                                     //   schema: { type: 'number' },\n                                                     //   path: '/y',\n                                                     //   value: undefined,\n                                                     //   message: 'Expected number'\n                                                     // }, {\n                                                     //   schema: { type: 'number' },\n                                                     //   path: '/z',\n                                                     //   value: undefined,\n                                                     //   message: 'Expected number'\n                                                     // }]\n```\n\nCompiled routines can be inspected with the `.Code()` function.\n\n```typescript\nconst C = TypeCompiler.Compile(Type.String())        // const C: TypeCheck<TString>\n\nconsole.log(C.Code())                                // return function check(value) {\n                                                     //   return (\n                                                     //     (typeof value === 'string')\n                                                     //   )\n                                                     // }\n```\n\n<a name='typesystem'></a>\n\n## TypeSystem\n\nThe TypeBox TypeSystem module provides functionality to define types above and beyond the Standard and Extended type sets as well as control various assertion polices. Configurations made to the TypeSystem module are observed by both `TypeCompiler` and `Value` modules.\n\nThe TypeSystem module is provided as an optional import.\n\n```typescript\nimport { TypeSystem } from '@sinclair/typebox/system'\n```\n\n<a name='typesystem-types'></a>\n\n### Types\n\nUse the `Type(...)` function to create a custom type. This function will return a type factory function that can be used to construct the type. The following creates a Point type.\n\n```typescript\ntype PointOptions = { }                              // The Type Options\n\ntype PointType = { x: number, y: number }            // The Static<T> Type\n\nconst Point = TypeSystem.Type<PointType, PointOptions>('Point', (options, value) => {\n  return (\n    typeof value === 'object' && value !== null &&\n    typeof value.x === 'number' && \n    typeof value.y === 'number'\n  )\n})\n\nconst T = Point()\n\ntype T = Static<typeof T>                             // type T = { x: number, y: number }\n\nconst R = Value.Check(T, { x: 1, y: 2 })              // const R = true\n```\n\n<a name='typesystem-formats'></a>\n\n### Formats\n\nUse the `Format(...)` function to create a custom string format. The following creates a format that checks for lowercase strings.\n\n```typescript\nTypeSystem.Format('lowercase', value => value === value.toLowerCase()) // format should be lowercase\n\nconst T = Type.String({ format: 'lowercase' })       \n\nconst A = Value.Check(T, 'Hello')                    // const A = false\n\nconst B = Value.Check(T, 'hello')                    // const B = true\n```\n\n<a name='typesystem-policies'></a>\n\n### Policies\n\nTypeBox validates using JSON Schema assertion policies by default. It is possible to override these policies and have TypeBox assert using TypeScript policies. The following overrides are available.\n\n```typescript\n// Allow arrays to validate as object types (default is false)\n//\n// const A: {} = [] - allowed in TS\n\nTypeSystem.AllowArrayObjects = true                  \n\n// Allow numeric values to be NaN or + or - Infinity (default is false)\n//\n// const A: number = NaN - allowed in TS\n\nTypeSystem.AllowNaN = true                      \n```\n\n<a name='benchmark'></a>\n\n## Benchmark\n\nThis project maintains a set of benchmarks that measure Ajv, Value and TypeCompiler compilation and validation performance. These benchmarks can be run locally by cloning this repository and running `npm run benchmark`. The results below show for Ajv version 8.12.0. \n\nFor additional comparative benchmarks, please refer to [typescript-runtime-type-benchmarks](https://moltar.github.io/typescript-runtime-type-benchmarks/).\n\n<a name='benchmark-compile'></a>\n\n### Compile\n\nThis benchmark measures compilation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/benchmark/measurement/module/compile.ts).\n\n```typescript\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┐\n│          (index)           │ Iterations │     Ajv      │ TypeCompiler │ Performance  │\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┤\n│ Literal_String             │    1000    │ '    257 ms' │ '      8 ms' │ '   32.13 x' │\n│ Literal_Number             │    1000    │ '    203 ms' │ '      4 ms' │ '   50.75 x' │\n│ Literal_Boolean            │    1000    │ '    183 ms' │ '      4 ms' │ '   45.75 x' │\n│ Primitive_Number           │    1000    │ '    174 ms' │ '      8 ms' │ '   21.75 x' │\n│ Primitive_String           │    1000    │ '    158 ms' │ '      9 ms' │ '   17.56 x' │\n│ Primitive_String_Pattern   │    1000    │ '    213 ms' │ '     13 ms' │ '   16.38 x' │\n│ Primitive_Boolean          │    1000    │ '    136 ms' │ '      6 ms' │ '   22.67 x' │\n│ Primitive_Null             │    1000    │ '    144 ms' │ '      6 ms' │ '   24.00 x' │\n│ Object_Unconstrained       │    1000    │ '   1176 ms' │ '     38 ms' │ '   30.95 x' │\n│ Object_Constrained         │    1000    │ '   1181 ms' │ '     31 ms' │ '   38.10 x' │\n│ Object_Vector3             │    1000    │ '    387 ms' │ '      8 ms' │ '   48.38 x' │\n│ Object_Box3D               │    1000    │ '   1693 ms' │ '     25 ms' │ '   67.72 x' │\n│ Tuple_Primitive            │    1000    │ '    470 ms' │ '     15 ms' │ '   31.33 x' │\n│ Tuple_Object               │    1000    │ '   1206 ms' │ '     17 ms' │ '   70.94 x' │\n│ Composite_Intersect        │    1000    │ '    567 ms' │ '     20 ms' │ '   28.35 x' │\n│ Composite_Union            │    1000    │ '    515 ms' │ '     21 ms' │ '   24.52 x' │\n│ Math_Vector4               │    1000    │ '    787 ms' │ '     10 ms' │ '   78.70 x' │\n│ Math_Matrix4               │    1000    │ '    386 ms' │ '      8 ms' │ '   48.25 x' │\n│ Array_Primitive_Number     │    1000    │ '    349 ms' │ '      7 ms' │ '   49.86 x' │\n│ Array_Primitive_String     │    1000    │ '    336 ms' │ '      4 ms' │ '   84.00 x' │\n│ Array_Primitive_Boolean    │    1000    │ '    284 ms' │ '      3 ms' │ '   94.67 x' │\n│ Array_Object_Unconstrained │    1000    │ '   1704 ms' │ '     19 ms' │ '   89.68 x' │\n│ Array_Object_Constrained   │    1000    │ '   1456 ms' │ '     18 ms' │ '   80.89 x' │\n│ Array_Tuple_Primitive      │    1000    │ '    792 ms' │ '     15 ms' │ '   52.80 x' │\n│ Array_Tuple_Object         │    1000    │ '   1552 ms' │ '     17 ms' │ '   91.29 x' │\n│ Array_Composite_Intersect  │    1000    │ '    744 ms' │ '     18 ms' │ '   41.33 x' │\n│ Array_Composite_Union      │    1000    │ '    783 ms' │ '     15 ms' │ '   52.20 x' │\n│ Array_Math_Vector4         │    1000    │ '   1093 ms' │ '     14 ms' │ '   78.07 x' │\n│ Array_Math_Matrix4         │    1000    │ '    684 ms' │ '      6 ms' │ '  114.00 x' │\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┘\n```\n\n<a name='benchmark-validate'></a>\n\n### Validate\n\nThis benchmark measures validation performance for varying types. You can review this benchmark [here](https://github.com/sinclairzx81/typebox/blob/master/benchmark/measurement/module/check.ts).\n\n```typescript\n┌────────────────────────────┬────────────┬──────────────┬──────────────┬──────────────┬──────────────┐\n│          (index)           │ Iterations │  ValueCheck  │     Ajv      │ TypeCompiler │ Performance  │\n├────────────────────────────┼────────────┼──────────────┼──────────────┼──────────────┼──────────────┤\n│ Literal_String             │  1000000   │ '     27 ms' │ '      6 ms' │ '      5 ms' │ '    1.20 x' │\n│ Literal_Number             │  1000000   │ '     23 ms' │ '     21 ms' │ '     11 ms' │ '    1.91 x' │\n│ Literal_Boolean            │  1000000   │ '     21 ms' │ '     20 ms' │ '     10 ms' │ '    2.00 x' │\n│ Primitive_Number           │  1000000   │ '     26 ms' │ '     19 ms' │ '     11 ms' │ '    1.73 x' │\n│ Primitive_String           │  1000000   │ '     25 ms' │ '     19 ms' │ '     10 ms' │ '    1.90 x' │\n│ Primitive_String_Pattern   │  1000000   │ '    155 ms' │ '     49 ms' │ '     43 ms' │ '    1.14 x' │\n│ Primitive_Boolean          │  1000000   │ '     23 ms' │ '     19 ms' │ '     10 ms' │ '    1.90 x' │\n│ Primitive_Null             │  1000000   │ '     24 ms' │ '     19 ms' │ '     10 ms' │ '    1.90 x' │\n│ Object_Unconstrained       │  1000000   │ '    804 ms' │ '     35 ms' │ '     28 ms' │ '    1.25 x' │\n│ Object_Constrained         │  1000000   │ '   1041 ms' │ '     55 ms' │ '     41 ms' │ '    1.34 x' │\n│ Object_Vector3             │  1000000   │ '    380 ms' │ '     26 ms' │ '     20 ms' │ '    1.30 x' │\n│ Object_Box3D               │  1000000   │ '   1785 ms' │ '     65 ms' │ '     52 ms' │ '    1.25 x' │\n│ Object_Recursive           │  1000000   │ '   4984 ms' │ '    396 ms' │ '    114 ms' │ '    3.47 x' │\n│ Tuple_Primitive            │  1000000   │ '    168 ms' │ '     24 ms' │ '     16 ms' │ '    1.50 x' │\n│ Tuple_Object               │  1000000   │ '    673 ms' │ '     30 ms' │ '     26 ms' │ '    1.15 x' │\n│ Composite_Intersect        │  1000000   │ '    751 ms' │ '     28 ms' │ '     20 ms' │ '    1.40 x' │\n│ Composite_Union            │  1000000   │ '    489 ms' │ '     24 ms' │ '     16 ms' │ '    1.50 x' │\n│ Math_Vector4               │  1000000   │ '    259 ms' │ '     23 ms' │ '     13 ms' │ '    1.77 x' │\n│ Math_Matrix4               │  1000000   │ '   1002 ms' │ '     40 ms' │ '     30 ms' │ '    1.33 x' │\n│ Array_Primitive_Number     │  1000000   │ '    252 ms' │ '     22 ms' │ '     15 ms' │ '    1.47 x' │\n│ Array_Primitive_String     │  1000000   │ '    227 ms' │ '     22 ms' │ '     18 ms' │ '    1.22 x' │\n│ Array_Primitive_Boolean    │  1000000   │ '    150 ms' │ '     23 ms' │ '     22 ms' │ '    1.05 x' │\n│ Array_Object_Unconstrained │  1000000   │ '   4754 ms' │ '     71 ms' │ '     64 ms' │ '    1.11 x' │\n│ Array_Object_Constrained   │  1000000   │ '   4787 ms' │ '    142 ms' │ '    123 ms' │ '    1.15 x' │\n│ Array_Object_Recursive     │  1000000   │ '  19088 ms' │ '   1735 ms' │ '    314 ms' │ '    5.53 x' │\n│ Array_Tuple_Primitive      │  1000000   │ '    650 ms' │ '     41 ms' │ '     31 ms' │ '    1.32 x' │\n│ Array_Tuple_Object         │  1000000   │ '   2770 ms' │ '     67 ms' │ '     55 ms' │ '    1.22 x' │\n│ Array_Composite_Intersect  │  1000000   │ '   2693 ms' │ '     50 ms' │ '     39 ms' │ '    1.28 x' │\n│ Array_Composite_Union      │  1000000   │ '   1982 ms' │ '     72 ms' │ '     33 ms' │ '    2.18 x' │\n│ Array_Math_Vector4         │  1000000   │ '   1068 ms' │ '     40 ms' │ '     26 ms' │ '    1.54 x' │\n│ Array_Math_Matrix4         │  1000000   │ '   4609 ms' │ '    115 ms' │ '     88 ms' │ '    1.31 x' │\n└────────────────────────────┴────────────┴──────────────┴──────────────┴──────────────┴──────────────┘\n```\n\n<a name='benchmark-compression'></a>\n\n### Compression\n\nThe following table lists esbuild compiled and minified sizes for each TypeBox module.\n\n```typescript\n┌──────────────────────┬────────────┬────────────┬─────────────┐\n│       (index)        │  Compiled  │  Minified  │ Compression │\n├──────────────────────┼────────────┼────────────┼─────────────┤\n│ typebox/compiler     │ '124.3 kb' │ ' 55.7 kb' │  '2.23 x'   │\n│ typebox/errors       │ '107.8 kb' │ ' 47.9 kb' │  '2.25 x'   │\n│ typebox/system       │ ' 73.3 kb' │ ' 30.2 kb' │  '2.43 x'   │\n│ typebox/value        │ '170.7 kb' │ ' 74.2 kb' │  '2.30 x'   │\n│ typebox              │ ' 72.0 kb' │ ' 29.7 kb' │  '2.43 x'   │\n└──────────────────────┴────────────┴────────────┴─────────────┘\n```\n\n<a name='contribute'></a>\n\n## Contribute\n\nTypeBox is open to community contribution. Please ensure you submit an open issue before submitting your pull request. The TypeBox project preferences open community discussion prior to accepting new features.\n",
    "licenseText": "TypeBox: JSON Schema Type Builder with Static Type Resolution for TypeScript \n\nThe MIT License (MIT)\n\nCopyright (c) 2017-2023 Haydn Paterson (sinclair) <haydn.developer@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE."
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/@sinclair/typebox/-/typebox-0.27.8.tgz#6667fac16c436b5434a387a34dedb013198f6e6e",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/@sinclair/typebox/-/typebox-0.27.8.tgz",
    "hash": "6667fac16c436b5434a387a34dedb013198f6e6e",
    "integrity": "sha512-+Fj43pSMwJs4KRrH/938Uf+uAELIgVBmQzg/q1YG10djyfA3TnrU8N8XzqCh/okZdszqBQTZf96idMfE5lnwTA==",
    "registry": "npm",
    "packageName": "@sinclair/typebox",
    "cacheIntegrity": "sha512-+Fj43pSMwJs4KRrH/938Uf+uAELIgVBmQzg/q1YG10djyfA3TnrU8N8XzqCh/okZdszqBQTZf96idMfE5lnwTA== sha1-Zmf6wWxDa1Q0o4ejTe2wExmPbm4="
  },
  "registry": "npm",
  "hash": "6667fac16c436b5434a387a34dedb013198f6e6e"
}