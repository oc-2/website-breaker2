{
  "manifest": {
    "name": "@inquirer/core",
    "version": "10.1.0",
    "description": "Core Inquirer prompt API",
    "keywords": [
      "answer",
      "answers",
      "ask",
      "base",
      "cli",
      "command",
      "command-line",
      "confirm",
      "enquirer",
      "generate",
      "generator",
      "hyper",
      "input",
      "inquire",
      "inquirer",
      "interface",
      "iterm",
      "javascript",
      "menu",
      "node",
      "nodejs",
      "prompt",
      "promptly",
      "prompts",
      "question",
      "readline",
      "scaffold",
      "scaffolder",
      "scaffolding",
      "stdin",
      "stdout",
      "terminal",
      "tty",
      "ui",
      "yeoman",
      "yo",
      "zsh"
    ],
    "homepage": "https://github.com/SBoudrias/Inquirer.js/blob/main/packages/core/README.md",
    "repository": {
      "type": "git",
      "url": "https://github.com/SBoudrias/Inquirer.js.git"
    },
    "license": "MIT",
    "author": {
      "name": "Simon Boudrias",
      "email": "admin@simonboudrias.com"
    },
    "sideEffects": false,
    "type": "module",
    "exports": {
      "./package.json": "./package.json",
      ".": {
        "import": {
          "types": "./dist/esm/index.d.ts",
          "default": "./dist/esm/index.js"
        },
        "require": {
          "types": "./dist/commonjs/index.d.ts",
          "default": "./dist/commonjs/index.js"
        }
      }
    },
    "main": "./dist/commonjs/index.js",
    "module": "./dist/esm/index.js",
    "types": "./dist/commonjs/index.d.ts",
    "files": [
      "dist"
    ],
    "scripts": {
      "attw": "attw --pack",
      "tsc": "tshy"
    },
    "dependencies": {
      "@inquirer/figures": "^1.0.8",
      "@inquirer/type": "^3.0.1",
      "ansi-escapes": "^4.3.2",
      "cli-width": "^4.1.0",
      "mute-stream": "^2.0.0",
      "signal-exit": "^4.1.0",
      "strip-ansi": "^6.0.1",
      "wrap-ansi": "^6.2.0",
      "yoctocolors-cjs": "^2.1.2"
    },
    "devDependencies": {
      "@arethetypeswrong/cli": "^0.17.0",
      "@inquirer/testing": "^2.1.37",
      "@repo/tsconfig": "workspace:*",
      "@types/mute-stream": "^0.0.4",
      "@types/node": "^22.9.0",
      "@types/wrap-ansi": "^3.0.0",
      "tshy": "^3.0.2"
    },
    "engines": {
      "node": ">=18"
    },
    "publishConfig": {
      "access": "public"
    },
    "tshy": {
      "exclude": [
        "src/**/*.test.ts"
      ],
      "exports": {
        "./package.json": "./package.json",
        ".": "./src/index.ts"
      }
    },
    "gitHead": "84e49bdb552e1cb4f035d644190913f367a66e74",
    "_registry": "npm",
    "_loc": "/home/runner/website-breaker2/.cache/yarn/v6/npm-@inquirer-core-10.1.0-c5fdc34c4cafd7248da29a3c3b3120fe6e1c45be-integrity/node_modules/@inquirer/core/package.json",
    "readmeFilename": "README.md",
    "readme": "# `@inquirer/core`\n\nThe `@inquirer/core` package is the library enabling the creation of Inquirer prompts.\n\nIt aims to implements a lightweight API similar to React hooks - but without JSX.\n\n# Installation\n\n<table>\n<tr>\n  <th>npm</th>\n  <th>yarn</th>\n</tr>\n<tr>\n<td>\n\n```sh\nnpm install @inquirer/core\n```\n\n</td>\n<td>\n\n```sh\nyarn add @inquirer/core\n```\n\n</td>\n</tr>\n</table>\n\n# Usage\n\n## Basic concept\n\nVisual terminal apps are at their core strings rendered onto the terminal.\n\nThe most basic prompt is a function returning a string that'll be rendered in the terminal. This function will run every time the prompt state change, and the new returned string will replace the previously rendered one. The prompt cursor appears after the string.\n\nWrapping the rendering function with `createPrompt()` will setup the rendering layer, inject the state management utilities, and wait until the `done` callback is called.\n\n```ts\nimport { createPrompt } from '@inquirer/core';\n\nconst input = createPrompt((config, done) => {\n  // Implement logic\n\n  return '? My question';\n});\n\n// And it is then called as\nconst answer = await input({\n  /* config */\n});\n```\n\n## Hooks\n\nState management and user interactions are handled through hooks. Hooks are common [within the React ecosystem](https://react.dev/reference/react/hooks), and Inquirer reimplement the common ones.\n\n### State hook\n\nState lets a component “remember” information like user input. For example, an input prompt can use state to store the input value, while a list prompt can use state to track the cursor index.\n\n`useState` declares a state variable that you can update directly.\n\n```ts\nimport { createPrompt, useState } from '@inquirer/core';\n\nconst input = createPrompt((config, done) => {\n  const [index, setIndex] = useState(0);\n\n  // ...\n```\n\n### Keypress hook\n\nAlmost all prompts need to react to user actions. In a terminal, this is done through typing.\n\n`useKeypress` allows you to react to keypress events, and access the prompt line.\n\n```ts\nconst input = createPrompt((config, done) => {\n  useKeypress((key) => {\n    if (key.name === 'enter') {\n      done(answer);\n    }\n  });\n\n  // ...\n```\n\nBehind the scenes, Inquirer prompts are wrappers around [readlines](https://nodejs.org/api/readline.html). Aside the keypress event object, the hook also pass the active readline instance to the event handler.\n\n```ts\nconst input = createPrompt((config, done) => {\n  useKeypress((key, readline) => {\n    setValue(readline.line);\n  });\n\n  // ...\n```\n\n### Ref hook\n\nRefs let a prompt hold some information that isn’t used for rendering, like a class instance or a timeout ID. Unlike with state, updating a ref does not re-render your prompt. Refs are an “escape hatch” from the rendering paradigm.\n\n`useRef` declares a ref. You can hold any value in it, but most often it’s used to hold a timeout ID.\n\n```ts\nconst input = createPrompt((config, done) => {\n  const timeout = useRef(null);\n\n  // ...\n```\n\n### Effect Hook\n\nEffects let a prompt connect to and synchronize with external systems. This includes dealing with network or animations.\n\n`useEffect` connects a component to an external system.\n\n```ts\nconst chat = createPrompt((config, done) => {\n  useEffect(() => {\n    const connection = createConnection(roomId);\n    connection.connect();\n    return () => connection.disconnect();\n  }, [roomId]);\n\n  // ...\n```\n\n### Performance hook\n\nA common way to optimize re-rendering performance is to skip unnecessary work. For example, you can tell Inquirer to reuse a cached calculation or to skip a re-render if the data has not changed since the previous render.\n\n`useMemo` lets you cache the result of an expensive calculation.\n\n```ts\nconst todoSelect = createPrompt((config, done) => {\n  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);\n\n  // ...\n```\n\n### Rendering hooks\n\n#### Prefix / loading\n\nAll default prompts, and most custom ones, uses a prefix at the beginning of the prompt line. This helps visually delineate different questions, and provides a convenient area to render a loading spinner.\n\n`usePrefix` is a built-in hook to do this.\n\n```ts\nconst input = createPrompt((config, done) => {\n  const prefix = usePrefix({ status });\n\n  return `${prefix} My question`;\n});\n```\n\n#### Pagination\n\nWhen looping through a long list of options (like in the `select` prompt), paginating the results appearing on the screen at once can be necessary. The `usePagination` hook is the utility used within the `select` and `checkbox` prompts to cycle through the list of options.\n\nPagination works by taking in the list of options and returning a subset of the rendered items that fit within the page. The hook takes in a few options. It needs a list of options (`items`), and a `pageSize` which is the number of lines to be rendered. The `active` index is the index of the currently selected/selectable item. The `loop` option is a boolean that indicates if the list should loop around when reaching the end: this is the default behavior. The pagination hook renders items only as necessary, so it takes a function that can render an item at an index, including an `active` state, called `renderItem`.\n\n```js\nexport default createPrompt((config, done) => {\n  const [active, setActive] = useState(0);\n\n  const allChoices = config.choices.map((choice) => choice.name);\n\n  const page = usePagination({\n    items: allChoices,\n    active: active,\n    renderItem: ({ item, index, isActive }) => `${isActive ? \">\" : \" \"}${index}. ${item.toString()}`\n    pageSize: config.pageSize,\n    loop: config.loop,\n  });\n\n  return `... ${page}`;\n});\n```\n\n## `createPrompt()` API\n\nAs we saw earlier, the rendering function should return a string, and eventually call `done` to close the prompt and return the answer.\n\n```ts\nconst input = createPrompt((config, done) => {\n  const [value, setValue] = useState();\n\n  useKeypress((key, readline) => {\n    if (key.name === 'enter') {\n      done(answer);\n    } else {\n      setValue(readline.line);\n    }\n  });\n\n  return `? ${config.message} ${value}`;\n});\n```\n\nThe rendering function can also return a tuple of 2 string (`[string, string]`.) The first string represents the prompt. The second one is content to render under the prompt, like an error message. The text input cursor will appear after the first string.\n\n```ts\nconst number = createPrompt((config, done) => {\n  // Add some logic here\n\n  return [`? My question ${input}`, `! The input must be a number`];\n});\n```\n\n### Typescript\n\nIf using typescript, `createPrompt` takes 2 generic arguments.\n\n```ts\n// createPrompt<Value, Config>\nconst input = createPrompt<string, { message: string }>(// ...\n```\n\nThe first one is the type of the resolved value\n\n```ts\nconst answer: string = await input();\n```\n\nThe second one is the type of the prompt config; in other words the interface the created prompt will provide to users.\n\n```ts\nconst answer = await input({\n  message: 'My question',\n});\n```\n\n## Key utilities\n\nListening for keypress events inside an inquirer prompt is a very common pattern. To ease this, we export a few utility functions taking in the keypress event object and return a boolean:\n\n- `isEnterKey()`\n- `isBackspaceKey()`\n- `isSpaceKey()`\n- `isUpKey()` - Note: this utility will handle vim and emacs keybindings (up, `k`, and `ctrl+p`)\n- `isDownKey()` - Note: this utility will handle vim and emacs keybindings (down, `j`, and `ctrl+n`)\n- `isNumberKey()` one of 1, 2, 3, 4, 5, 6, 7, 8, 9, 0\n\n## Theming\n\nTheming utilities will allow you to expose customization of the prompt style. Inquirer also has a few standard theme values shared across all the official prompts.\n\nTo allow standard customization:\n\n```ts\nimport { createPrompt, usePrefix, makeTheme, type Theme } from '@inquirer/core';\nimport type { PartialDeep } from '@inquirer/type';\n\ntype PromptConfig = {\n  theme?: PartialDeep<Theme>;\n};\n\nexport default createPrompt<string, PromptConfig>((config, done) => {\n  const theme = makeTheme(config.theme);\n\n  const prefix = usePrefix({ status, theme });\n\n  return `${prefix} ${theme.style.highlight('hello')}`;\n});\n```\n\nTo setup a custom theme:\n\n```ts\nimport { createPrompt, makeTheme, type Theme } from '@inquirer/core';\nimport type { PartialDeep } from '@inquirer/type';\n\ntype PromptTheme = {};\n\nconst promptTheme: PromptTheme = {\n  icon: '!',\n};\n\ntype PromptConfig = {\n  theme?: PartialDeep<Theme<PromptTheme>>;\n};\n\nexport default createPrompt<string, PromptConfig>((config, done) => {\n  const theme = makeTheme(promptTheme, config.theme);\n\n  const prefix = usePrefix({ status, theme });\n\n  return `${prefix} ${theme.icon}`;\n});\n```\n\nThe [default theme keys cover](https://github.com/SBoudrias/Inquirer.js/blob/theme/packages/core/src/lib/theme.mts):\n\n```ts\ntype DefaultTheme = {\n  prefix: string | { idle: string; done: string };\n  spinner: {\n    interval: number;\n    frames: string[];\n  };\n  style: {\n    answer: (text: string) => string;\n    message: (text: string, status: 'idle' | 'done' | 'loading') => string;\n    error: (text: string) => string;\n    defaultAnswer: (text: string) => string;\n    help: (text: string) => string;\n    highlight: (text: string) => string;\n    key: (text: string) => string;\n  };\n};\n```\n\n# Examples\n\nYou can refer to any `@inquirer/prompts` prompts for real examples:\n\n- [Confirm Prompt](https://github.com/SBoudrias/Inquirer.js/blob/main/packages/confirm/src/index.mts)\n- [Input Prompt](https://github.com/SBoudrias/Inquirer.js/blob/main/packages/input/src/index.mts)\n- [Password Prompt](https://github.com/SBoudrias/Inquirer.js/blob/main/packages/password/src/index.mts)\n- [Editor Prompt](https://github.com/SBoudrias/Inquirer.js/blob/main/packages/editor/src/index.mts)\n- [Select Prompt](https://github.com/SBoudrias/Inquirer.js/blob/main/packages/select/src/index.mts)\n- [Checkbox Prompt](https://github.com/SBoudrias/Inquirer.js/blob/main/packages/checkbox/src/index.mts)\n- [Rawlist Prompt](https://github.com/SBoudrias/Inquirer.js/blob/main/packages/rawlist/src/index.mts)\n- [Expand Prompt](https://github.com/SBoudrias/Inquirer.js/blob/main/packages/expand/src/index.mts)\n\n```ts\nimport colors from 'yoctocolors';\nimport {\n  createPrompt,\n  useState,\n  useKeypress,\n  isEnterKey,\n  usePrefix,\n  type Status,\n} from '@inquirer/core';\n\nconst confirm = createPrompt<boolean, { message: string; default?: boolean }>(\n  (config, done) => {\n    const [status, setStatus] = useState<Status>('idle');\n    const [value, setValue] = useState('');\n    const prefix = usePrefix({});\n\n    useKeypress((key, rl) => {\n      if (isEnterKey(key)) {\n        const answer = value ? /^y(es)?/i.test(value) : config.default !== false;\n        setValue(answer ? 'yes' : 'no');\n        setStatus('done');\n        done(answer);\n      } else {\n        setValue(rl.line);\n      }\n    });\n\n    let formattedValue = value;\n    let defaultValue = '';\n    if (status === 'done') {\n      formattedValue = colors.cyan(value);\n    } else {\n      defaultValue = colors.dim(config.default === false ? ' (y/N)' : ' (Y/n)');\n    }\n\n    const message = colors.bold(config.message);\n    return `${prefix} ${message}${defaultValue} ${formattedValue}`;\n  },\n);\n\n/**\n *  Which then can be used like this:\n */\nconst answer = await confirm({ message: 'Do you want to continue?' });\n```\n\n# License\n\nCopyright (c) 2023 Simon Boudrias (twitter: [@vaxilart](https://twitter.com/Vaxilart))<br/>\nLicensed under the MIT license.\n",
    "licenseText": "Copyright (c) 2023 Simon Boudrias\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/@inquirer/core/-/core-10.1.0.tgz#c5fdc34c4cafd7248da29a3c3b3120fe6e1c45be",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/@inquirer/core/-/core-10.1.0.tgz",
    "hash": "c5fdc34c4cafd7248da29a3c3b3120fe6e1c45be",
    "integrity": "sha512-I+ETk2AL+yAVbvuKx5AJpQmoaWhpiTFOg/UJb7ZkMAK4blmtG8ATh5ct+T/8xNld0CZG/2UhtkdMwpgvld92XQ==",
    "registry": "npm",
    "packageName": "@inquirer/core",
    "cacheIntegrity": "sha512-I+ETk2AL+yAVbvuKx5AJpQmoaWhpiTFOg/UJb7ZkMAK4blmtG8ATh5ct+T/8xNld0CZG/2UhtkdMwpgvld92XQ== sha1-xf3DTEyv1ySNopo8OzEg/m4cRb4="
  },
  "registry": "npm",
  "hash": "c5fdc34c4cafd7248da29a3c3b3120fe6e1c45be"
}